<!DOCTYPE html>

<html>
<head>
  <title>sofia-tree.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>sofia-tree.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <pre><code>SofiaTree <span class="hljs-number">0.0</span><span class="hljs-number">.1</span>
</code></pre>
            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>A kind of <em>Radix tree</em> data structure baptized <strong>Sofia Tree</strong> in honour to my 
beloved daughter.</p>
<p>A multinode tree with a level for each letter with fast lookup operations.”
@see <a href="http://en.wikipedia.org/wiki/Radix_tree">http://en.wikipedia.org/wiki/Radix_tree</a></p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Author: Jaime Agudo <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#106;&#x61;&#105;&#x6d;&#x65;&#x2e;&#97;&#103;&#117;&#100;&#x6f;&#46;&#108;&#x6f;&#112;&#x65;&#122;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;">&#106;&#x61;&#105;&#x6d;&#x65;&#x2e;&#97;&#103;&#117;&#100;&#x6f;&#46;&#108;&#x6f;&#112;&#x65;&#122;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;</a></p>
<p>Github: <a href="https://github.com/jaimeagudo/sofiatree/">https://github.com/jaimeagudo/sofiatree/</a></p>
<p>License: MIT</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">

'use strict'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="sofiatree">SofiaTree</h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Tree constructor takes @param <code>options</code>. Actually <code>useCache</code>, a <code>boolean</code>
to indicate wether caches whole words list of the  subtree below the 
current node from its root. That way subsequent visits on that node won’t 
need to traverse its subtree. </p>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>This cache config value is  established just on the root node of the tree to 
avoid redundancy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> root = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">var</span> previous_SofiaTree = root.SofiaTree;

  <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> exports !== <span class="hljs-string">'undefined'</span> ) {
    <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">module</span>.exports ) {
      exports = <span class="hljs-built_in">module</span>.exports = SofiaTree;
    }
    exports.SofiaTree = SofiaTree;
  } 
  <span class="hljs-keyword">else</span> {
    root.SofiaTree = SofiaTree;
  }


  SofiaTree.noConflict = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  	root.SofiaTree = previous_SofiaTree;
  	<span class="hljs-keyword">return</span> SofiaTree;
  }



<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SofiaTree</span> <span class="hljs-params">(options)</span> </span>{
	options = options || {};

	<span class="hljs-keyword">this</span>.useCache=!!options.useCache;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Iterative tree traverse, friendlier with memory compsuntion.
Passing an empty string as prefix it will return all the words present in the
whole tree</p>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <ul>
<li><code>p</code> prefix above the current node</li>
<li><code>useCache</code> configuration value passed along from the root node one</li>
<li>@return the <code>matches</code> words list </li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
SofiaTree.prototype.__buildWordsArray=<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p, useCache)</span></span>{

	<span class="hljs-keyword">var</span> matches=[],
		nodesStack=[],
		prefixesStack=[],
		node,
		prefix;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Use stack to avoid recursion implementation overhead</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	nodesStack.push(<span class="hljs-keyword">this</span>);
	prefixesStack.push(p);

	<span class="hljs-keyword">while</span>(nodesStack.length){

		prefix=prefixesStack.pop();
		node=nodesStack.pop();</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Recursion base</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span>(node.isWord &amp;&amp; !node.cache)                      
			matches.push(prefix);

	   	<span class="hljs-keyword">if</span>(useCache &amp;&amp; node.cache){</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Shallow copies doesn’t work</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	   		node.cache.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(word)</span></span>{	   			
	   			matches.push(word);
	   		});
	   	}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node.children){</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Iterate whole subtree building words array and return it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	   		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> letter <span class="hljs-keyword">in</span> node.children){
	   			nodesStack.push(node.children[letter]);</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>A bit redundant, could be optimised</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	   			prefixesStack.push(prefix + letter);
	   		};
	   	}
	}
	<span class="hljs-keyword">if</span>(useCache)
		<span class="hljs-keyword">this</span>.cache=matches;

	<span class="hljs-keyword">return</span> matches;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Recursive implementation, to be deprecated
Passing an empty string as prefix it will return all the words present in the
whole tree</p>

            </div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <ul>
<li><code>p</code> prefix above the current node</li>
<li><code>useCache</code> configuration value passed along from the root node one</li>
<li><code>matches</code> out parameter to return the matches. It reduces stack 
grow on recursive calls</li>
<li>@returns <code>matches</code> the same matches word list</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
SofiaTree.prototype.__buildWordsArrayRec=<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p, useCache, matches)</span></span>{

	<span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.isWord &amp;&amp; !<span class="hljs-keyword">this</span>.cache)
		matches.push(p);</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Iterate whole subtree building words array and return it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>   	<span class="hljs-keyword">if</span>(useCache &amp;&amp; <span class="hljs-keyword">this</span>.cache){</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Shallow copies doesn’t work</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>   		<span class="hljs-keyword">this</span>.cache.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(word)</span></span>{	   			
   			matches.push(word);
   		});
   	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.children){
   		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> letter <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.children){
   			<span class="hljs-keyword">this</span>.children[letter].buildWordsArray(p + letter, matches);
   		}
   	}
	<span class="hljs-keyword">if</span>(useCache)
		<span class="hljs-keyword">this</span>.cache=matches;

	<span class="hljs-keyword">return</span> matches;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h2 id="sofiatree-getcompletions">SofiaTree.getCompletions</h2>

            </div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>It returns an array of the words present in the tree that start with the given prefix</p>
<ul>
<li><code>prefix</code> prefix to be completed</li>
<li><code>recursive</code> OPTIONAL, defaults to false. To use recursive implementation to traverse the tree and build the result array. </li>
<li>return <code>matches</code> the array of words that start with the given prefix</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
SofiaTree.prototype.getCompletions= <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(prefix, recursive)</span></span>{
	prefix= <span class="hljs-keyword">typeof</span> prefix == <span class="hljs-string">'string'</span> ? prefix.toLowerCase() : <span class="hljs-string">""</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Tree depth index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> depth, node;</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Find the root node of the subtree which contains all the completions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span>(depth=<span class="hljs-number">0</span>, node=<span class="hljs-keyword">this</span>; depth &lt; prefix.length; depth++){
    	<span class="hljs-keyword">if</span>(!node.children || !node.children[prefix[depth]])
    		<span class="hljs-keyword">return</span> [];

    	node = node.children[prefix[depth]];
    } 
		
	<span class="hljs-keyword">return</span> recursive ? node.__buildWordsArrayRec(prefix, <span class="hljs-keyword">this</span>.useCache, []) : 
					   node.__buildWordsArray(prefix, <span class="hljs-keyword">this</span>.useCache);
	
}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h2 id="sofiatree-insert">SofiaTree.insert</h2>

            </div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Insert the composing letters of the given word along the tree marking its 
last node as word. It will insert a lower case version of the given word and
it won’t duplicate words</p>
<ul>
<li>param <code>word</code> to be inserted</li>
<li>return <code>this</code> for chaining convenience</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>SofiaTree.prototype.insert= <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(word)</span></span>{
    <span class="hljs-keyword">var</span> depth;
	<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>This eliminate empty strings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> word != <span class="hljs-string">'string'</span> || !word.length)
    	<span class="hljs-keyword">return</span>;

    word=word.toLowerCase();</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Find the last letter of the new word already present in the tree</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span>(depth=<span class="hljs-number">0</span>; depth &lt; word.length &amp;&amp; node.children &amp;&amp; node.children[word[depth]]; depth++ ){ 
    	node = node.children[word[depth]]
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Append new nodes for each remaining letter, if necessary. This eliminate duplicates</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (depth &lt; word.length)
    	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Create a new children property </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(! node.children)
				node.children={};

			node.children[word[depth]]=<span class="hljs-keyword">new</span> SofiaTree();</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>We already inserted the last word letter, make the node as a word</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	        <span class="hljs-keyword">if</span>(depth +<span class="hljs-number">1</span> === word.length){
	        	node.children[word[depth]].isWord=<span class="hljs-literal">true</span>;
	        	<span class="hljs-keyword">break</span>;
	        }
	        node = node.children[word[depth]];
	        depth++;
	    }
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}



}).call(<span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
